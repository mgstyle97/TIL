# 9. 우선순위 큐

## 9.1 우선순위 큐 추상 데이터 타입

### 우선순위 큐의 소개

- **우선순위 큐(priority queue)** : 우선 순위의 개념을 큐에 도입한 자료구조이다.

  - 보통의 큐는 선입 선출(FIFO)의 원칙에 의하여 먼저 들어온 데이터가 먼저 나가게 된다. 
  - 우선순위 큐에서는 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나가게 된다.
  - **스택, 큐, 우선순위 큐 비교**

  |  자료구조   |        삭제되는 요소        |
  | :---------: | :-------------------------: |
  |    스택     |  가장 최근에 들어온 데이터  |
  |     큐      |   가장 먼저 들어온 데이터   |
  | 우선순위 큐 | 가장 우선순위가 높은 데이터 |

  - 우선순위 큐는 가장 일반적인 큐라 할 수 있다.
    - 스택이나 큐도 우선순위 큐를 사용하여 얼마든지 구현할 수 있기 때문이다.
    - 즉, 적절한 우선 순위만 부여하면 우선순위 큐는 스택이나 큐로 동작할 것이다.
  - 우선순위 큐는 컴퓨터의 여러 분야에서 이용되는데, 대표적으로 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영 체제에서의 작업 스케줄링, 수치 해석적인 계산 등에 사용된다.

  - 우선순위 큐는 배여르 연결 리스트 등의 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 히프(heap)이다.

### 우선순위 큐 추상자료형

```
- 객체: n개의 element형의 우선 순위를 가진 요소들의 모임
- 연산:
create()	::= 우선순위 큐를 생성한다.
init(q)		::= 우선순위 큐 q를 초기화 한다.
is_empty(q)	::= 우선순위 큐 q가 비어있는지를 검사한다.
is_full(q)	::= 우선순위 큐 q가 가득 찼는가를 검사한다.
insert(q, x)::= 우선순위 큐 q에 요소 x를 추가한다.
delete(q)	::= 우선순위 큐로부터 가장 우선순위가 높은 요소를 삭제하고 반환한다.
find(q)		::= 우선 순위가 가장 높은 요소를 반환한다.
```

- 우선순위 큐는 0개 이상의 요소의 모임이다.
- 각 요소들은 우선 순위값을 가지고 있다.
- 가장 중요한 연산은 insert 연산(요소 삽입), delete 연산(요소 삭제)이다.
- 우선순위 큐는 2가지로 구분할 수 있다.
  - 최소 우선순위 큐 : 가장 우선 순위가 낮은 요소를 먼저 삭제한다.
  - 최대 우선순위 큐 : 가장 우선 순위가 높은 요소를 먼저 삭제한다.



## 9.2 우선순위 큐의 구현 방법

### 배열을 사용하는 방법

- 정렬되어 있지 않은 배열
  - 정렬이 안 된 배열을 사용하게 되면 삽입은 배열의 맨 끝에 새로운 요소를 추가하면 된다. 시간 복잡도는 O(1)이다.
  - 삭제 연산을 할 때는 가장 우선 순위가 높은 요소를 찾아야 한다.
    - 정령이 안되어 있으므로 처음부터 끝까지 모든 요소들을 스캔하여야 한다. 따라서 시간 복잡도는 O(n)이다.
    - 요소가 삭재된 다음, 뒤에 있는 요소들을 앞으로 이동시켜야 하는 부담 또한 있다.
- 정렬되어 있는 배열
  - 새로운 요소를 삽입할 때는 다른 요소와 값을 비교하여 적절한 삽입 위치를 결정하여야 한다.
    - 삽입 위치를 찾기 위하여 순차탐색이나 이진탐색과 같은 방법을 이용할 수 있다.
    - 삽입 위치를 찾은 다음에는 삽입 위치 뒤에 있는 요소들을 이동시켜서 빈자리를 만든 다음, 삽입해야 한다. 따라서 시간 복잡도는 O(n)이다.
  - 삭제 시에는 맨 뒤에 위치한 우선 순위가 높은 요소를 삭제하면 된다. 따라서 시간 복잡도는 O(n)이 된다.
  
  <img src="./picture/array priority queue.PNG">



### 연결 리스트를 사용하는 방법

- 정렬되어 있지 않은 연결 리스트
  - 삽입 시에는 첫 번째 노드로 삽입시키는 것이 유리하다.
    - 또한 사입 시에 배열과 달리 다른 노드를 이동할 필요가 없다. 포인터만 변경하면 된다. 따라서 삽입의 시간 복잡도는 O(1)이다.
  - 삭제 시에는 포인터를 따라서 모든 노드를 확인해봐야 한다. 이 경우 시간 복잡도는 O(n)이 된다.
- 정령되어 있는 연결 리스트
  - 이 경우에는 우선  순위가 높은 요소가 앞에 위치하는 것이 유리하다.
  - 삽입시에는 우선 순위값을 기준으로 삽입위치를 찾아야 하므로 시간 복잡도는 O(n)이 된다.
  - 삭제 시에는첫 번째 노드를 삭제하면 되므로 시간 복잡도는 O(1)이다.
  
  <img src="./picture/linked list priority queue.PNG">

 

### 히프를 사용하는 방법

- **히프(heap)** : 완전 이진 트리의 일종으로 우선순위 큐를 위하여 특별히 만들어진 자료 구조이다.

  - 히프는 일종의 느슨한 정렬 상태를 유지한다. 즉, 완전히 정렬된 것은 아니지만 전혀 정렬이 안 된 것도 아닌 상태를 유지한다.
  - 이러한 느슨한 정렬 상태를 이용하여 우선순위 큐를 구현한다.
  - 히프의 시간 복잡도는 O(log<sub>2</sub>n)으로서 다른 방법보다 상당히 유리하다.

  | 표현 방법             | 삽입                | 삭제                |
  | --------------------- | ------------------- | ------------------- |
  | 순서 없는 배열        | O(1)                | O(n)                |
  | 순서 없는 연결 리스트 | O(1)                | O(n)                |
  | 정렬된 배열           | O(n)                | O(1)                |
  | 정렬된 연결 리스트    | O(n)                | O(1)                |
  | 히프                  | O(log<sub>2</sub>n) | O(log<sub>2</sub>n) |

  