# 2. 변수와 타입

## 2.1 변수

### 2.1.1 변수란?

- 프로그램은 작업을 처리하는 과정에서 필요에 따라 데이터를 메모리에 저장한다.

- **변수(Variable)** : 값을 저장할 수 있는 메모리의 공간을 의미한다.

  - 변수란 이름을 갖게 된 이유는 프로그램에 의해서 수시로 값이 변동될 수 있기 때문이다.
  - 변수에는 복수 개의 값을 저장할 수  없고, 하나의 값만 저장할 수 있다.

  ```
  변수란, 하나의 값을 저장할 수 있는 메모리 공간이다.
  ```

  - 변수에는 다양한 타입의 값을 저장할 수 없고, 한 가지 타입의 값만 저장할 수 있다.



### 2.1.2 변수의 선언

- 변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무엇인지를 결정한다.

  ```java
  int age;			//정수(int)값을 저장할 수 있는 age 변수 선언
  double value;		//실수(double)값을 저장할 수 있는 value 변수 선언
  ```

  - 타입은 변수에 저장되는 값의 종류와 범위를 결정짓는 요소이기 때문에 어떤 값을 변수에 저장할지 충분히 생각한 다음 결정해야 한다.
  - 같은 타입의 변수는 콤마(,)를 이용해서 한꺼번에 선언할 수도 있다.

  ```java
  int x, y, z;
  ```

  - 변수 이름은 메모리 주소에 붙여진 이름이다.
    - 프로그램은 변수 이름을 통해서 메모리 주소에 접근하고, 그곳에 값을 저장하거나 그곳에 있는 값을 읽는다.
  - 변수 이름은 자바 언어에서 정한 명명 규칙(naming convention)을 따라야 한다.

| 작성 규칙                                                    | 예                                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 첫 번째 글자는 문자이거나 '$', '_'이어야 하고 숫자로 시작할 수 없다.(필수) | <p>가능: price, $price, _companyName</p>안됨: 1v, @speed, $#value |
| 영어 대소문자가 구분된다.(필수)                              | firstname과 firstName은 다른 변수                            |
| 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다.(관례) | maxSpeed, firstName, carBodyColor                            |
| 문자 수(길이)의 제한은 없다.                                 |                                                              |
| 자바 예약어는 사용할 수 없다.(필수)                          |                                                              |

- 자바는 예약어를 가지고 있는데, 이 예약어들로 변수 이름을 지정하면 컴파일 에러가 발생하기 때문에 주의해야 한다.

| 분류                  | 예약어                                                       |
| :-------------------- | ------------------------------------------------------------ |
| 기본 데이터 타입      | boolean, byte, char, short, int, long, float, double         |
| 접근 지정자           | private, protected, public                                   |
| 클래스와 관련된 것    | class, abstract, interface, extends, implements, enum        |
| 객체와 관련된 것      | new, instanceof, this, super, null                           |
| 메소드와 관련된 것    | void, return                                                 |
| 제어문과 관련된 것    | if, else, switch, case, default, for, do, while, break, continue |
| 논리값                | true, false                                                  |
| 예외 처리와 관련된 것 | try, catch, finally, throw, throws                           |
| 기타                  | transient, volatile, package, import, synchronized, native, final, static, strictfp, assert |

- 개발자는 변수 이름을 보고, 이 변수가 어떤 값을 저장하고 있는지 쉽게 알 수 있도록 의미 있는 변수 이름을 지어주는 것이 좋다.
  - 변수 이름의 길이는 프로그램 실행과는 무관하기 때문에 충분히 길어도 상관없다.
  - 필수적인 것은 아니지만 명명 규칙과 관련된 자바 개발자들 간에 지켜져오는 관례가 있는데, 관례란 필수적인 것은 아니지만 개발자 간의 코드 작성 패턴을 공유하고자 하는 약속이기 때문에 가급적 지켜주는 것이 좋다.
  - 변수 이름에 한글도 사용이 가능하지만 가급적이면 한글을 포함하지 않는 것이 좋다.
    - 한국어를 모르는 다른 사람도 소스 코드를 볼 수 있기 때문이다.



### 2.1.3 변수의 사용

- 변술를 사용한다는 것은 변수에 값을 저장하고 읽는 행위를 말한다.

#### 변수값 저장

- 변수에 값을 저장할 때에는 대입 연산자(=)를 사용한다.

  - 일반 수학에서 =은 같다는 의미지만, 자바 언어에서는 우측의 값을 좌측 변수에 저장한다는 의미를 갖는다.
  - 변수를 선언하고 처음 값을 저장할 경우, 이러한 값을 초기값이라고 한다.
    - 변수에 초기값을 주는 행위를 변수의 초기화라고 한다.

  ```java
  int score;		// 변수 선언
  score = 90;		// 값 저장
  ```

  - 초기값은 변수를 선언함과 동시에 줄 수도 있다.

  ```java
  int score = 90;
  ```

- **리터럴(literal)** : 변수에 초기값은 코드에서 직접 입력하는 경우가 많은데, 소스 코드 내에서 직접 입력된 값

  - 리터럴은 값에 종류에 따라 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴로 구분된다.

  - 리터럴은 상수(constant)와 같은 의미지만, 프로그램에서는 상수를 "값을 한 번 저장하면 변경할 수 없는 변수"로 정의하기 때문에 "리터럴"이라는 용어를 사용한다.

  - **정수 리터럴**

    > - 소수점이 없는 정수 리터럴은 10진수로 간주한다.
    >
    > ```
    > 0, 75, -100
    > ```
    >
    > - 0으로 시작되는 리터럴은 8진수로 간주한다.
    >
    > ```
    > 02, -04
    > ```
    >
    > - 0x 또는 0X로 시작하고 0~9 숫자나 A, B, C, D, E, F 또는 a, b, c, d, e, f로 구성된 리터럴은 16진수로 간주된다.
    >
    > ```
    > 0x5, 0xA, 0xB3, 0xAC08
    > ```
    >
    > 정수 리터럴은 저장할 수 있는 타입은 byte, char, short, int, long과 같이 5개가 있다.

  - **실수 리터럴**

    > - 소수점이 있는 리터럴은 10진수 실수로 간주한다.
    >
    > ```
    > 0.25, -3.14
    > ```
    >
    > - 대문자 E 또는 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주한다.
    >
    > ```
    > 5E7			// 5 x 10^7
    > 0.12E-5		// 0.12 x 10^-5
    > ```
    >
    > 실수 리터럴을 저장할 수 있는 타입은 float, double이 있다.

  - **문자 리터럴**

    > - 작은 따옴표(')로 묶은 텍스트는 하나의 문자 리터럴로 간주한다.
    >
    > ```
    > 'A', '한', '\t', '\n'
    > ```
    >
    > - 역슬래쉬(\\)가 붙은 문자 리터럴은 이스케이프(escape) 문자라고도 한다.
    >
    > | 이스케이프 문자 | 용도                       | 유니코드      |
    > | --------------- | -------------------------- | ------------- |
    > | '\t'            | 수평 탭                    | 0x0009        |
    > | '\n'            | 줄 바꿈                    | 0x000a        |
    > | '\r'            | 리턴                       | 0x000d        |
    > | '\\"'           | "(큰따옴표)                | 0x0022        |
    > | '\\''           | '(작은따옴표)              | 0x0027        |
    > | '\\\\'          | \                          | 0x005c        |
    > | '\u16진수'      | 16진수에 해당하는 유니코드 | 0x0000~0xffff |
    >
    > 문자 리터럴을 저장할 수 있는 타입은 char 하나뿐이다.

  - **문자열 리터럴**

    > - 큰따옴표(")로 묶은 텍스트는 문자열로 간주한다. 큰따옴표 안에는 텍스트가 없어도 문자열 리터럴로 간주된다. 문자열 리터럴 내부에서도 이스케이프 문자를 사용할 수 있다.
    >
    > ```
    > "대한민국"
    > "탭 만큼 이동 \t 합니다."
    > "한줄 내려 쓰기 \n 합니다."
    > ```
    >
    > 문자열 리터럴을 저장할 수 있는 타입은 String 하나뿐이다.

  - **논리 리터럴**

    > true와 false는 논리 리터럴로 간주한다.
    >
    > ```
    > true, false
    > ```
    >
    > 논리 리터럴을 저장할 수 있는 타입은 boolean 하나뿐이다.



#### 변수값 읽기

- 변수는 초기화가 되어야 읽을 수가 있고, 초기화가 되지 않는 변수는 읽을 수가 없다.

  ```java
  int value;					// 변수 value 선언(초기화 안됨)
  int result = value + 10;	// 변수 value 값을 읽고 10을 더한 값을 변수 result에 저장
  ```

  - 변수 value가 선언되었지만, 초기화가 되지 않았기 때문에 산술 연산식 value + 10에서 사용할 수 없다.

  ```java
  int value = 30;					// 변수 value가 30으로 초기화됨
  int result = value + 10;		// 변수 value 값을 읽고 10을 더한 값(40)을 result에 저장
  ```



### 2.1.4 변수의 사용 범위

- 변수는 중괄호 {} 블록 내에서 선언되고 사용된다.

  - 중괄호 블록을 사용하는 곳은 클래스, 생성자, 메소드이다.
  - 메소드 블록 내에서 선언된 변수를 특히 로컬 변수(local variable)라고 부른다.
    - 로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.

  <img src="./picture/block.PNG">

  - 변수는 메소드 블록 내 어디에서든 선언할 수 있지만, 변수 사용은 제한이 따른다.

    ```
    변수는 선언된 블록 내에서만 사용이 가능하다.
    ```

  - 메소드 블록내에서도 여러가지 중괄호 {} 블록들이 있을 수 있다.
    - 조건문에 해당하는 if(){}, 반복문에 해당하는 for(){}, while(){} 등이 중괄호를 가질 수 있다.
    - 이러한 if, for, while을 제어문이라고 하는데, 제어문 블록에서 선언된 변수는 해당 제어문 블록 내에서만 사용이 가능하고 블록 밖에서는 사용할 수 없다.

  <img src="./picture/control block.PNG">

  - 변수를 선언할 때에는 어떤 범위에서 사용될 것인지를 생각하고, 선언 위치를 결정해야 한다.

    - 메소드 블록에서 어떤 위치에서건 사용할 수 있도록 한다면 메소드 블록 첫머리에 선언하는 것이 좋다.

    ````java
    public class VariableScopeExample{
        public static void main(String[] args){
            int v1 = 15;
            if(v1 > 10){
                int v2 = v1 - 10;
            }
            int v3 = v1 + v2 + 5;	// v2 변수를 사용할 수 없기 때문에 컴파일 에러가 생김
        }
    }
    ````

    - v2가 선언된 곳은 if 블록 내부이기 때문에 블록 바깥에서 사용할 수 없다.



## 2.2 데이터 타입

- 모든 변수에는 타입이 있으며, 타입에 따라 저장할 수 있는 값의 종류와 범위가 달라진다.
- 변수를 선언할 때 주어진 타입은 변수를 사용하는 도중에 변경할 수 없다.
  - 선언할 때 어떤 타입을 사용할지 충분히 고려해야한다.



### 2.2.1 기본(원시: private) 타입

- 기본(원시) 타입이란 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말한다.

  - 정수 타입 : byte, char, short, int, long
  - 실수 타입 : float, double
  - 논리 타입 : boolean

  <img src="./picture/variable memory.PNG">

- 메모리에는 0과 1을 저장하는 최소 기억 단위인 비트(bit)가 있다. 그리고 8개의 비트를 묶어서 바이트(byte)라고 한다.

- 기본 타입은 정해진 메모리 사용 크기(바이트 크기)로 값을 저장하는데 바이트 크기가 클수록 표현하는 값의 범위가 크다.

  - 정수 타입일 경우 -2<sup>n-1</sup>~2<sup>n-1</sup>-1의 값을 저장할 수 있는데, 여기서 n이 메모리 사용 크기(bit 수)이다.
  - 실수 타입일 경우 가수와 지수 부분에 사용되는 bit 크기에 따라서 값의 범위가 결정된다.



### 2.2.2 정수 타입(byte, char, short, int, long)

- 정수 타입에는 모두 다섯 개의 타입이 있으며 저장할 수 있는 값의 범위가 서로 다르다.

  | 정수 타입 | byte | char | short | int  | long |
  | --------- | ---- | ---- | ----- | ---- | ---- |
  | 바이트 수 | 1    | 2    | 2     | 4    | 8    |

  - 자바는 기본적으로 정수 연산을 int 타입으로 수행한다.
    - 저장하려는 값이 정수 리터럴이라면 특별한 이유가 없는 한 int 타입 변수에 저장하는 것이 좋다.



#### byte 타입

- byte 타입은 색상 정보 및 파일 또는 이미지 등의 이진(바이너리) 데이터를 처리할 때 주로 사용된다.

- byte 타입은 정수 타입 중에서 가장 작은 범위의 수를 저장하는데, 표현할 수 있는 값의 범위는 -128~127(-2<sup>7</sup>~2<sup>7</sup>-1)이다.

  - 만약 -128~127를 초과하는 값이 byte 타입 변수에 저장될 경우 **컴파일 에러("Type mismatch:cannot convert from int to byte")**가 발생한다.
  - byte 타입은 1byte, 즉 8bit 크기를 가지므로 0과 1이 8개로 구성된 이진수로 표현하면 -128~127 범위의 값을 가질 수 있다.
  - byte 타입보다 크기가 큰 short, int, long 타입도 전체 바이트 수만 다를 뿐 동일한 원리로 정수값을 표현한다.

  <img src="./picture/ByteExample.PNG">

- 코드에서 정상적으로 변수에 올바른 값을 저장하더라도 프로그램이 실행하는 도중에 변수의 값은 변경된다.

  - 실행 중에 저장할 수 있는 값의 범위를 초과하면 최소값부터 다시 반복 저장되는데, byte일 경우 -128(최소값)부터 시작해서 127(최대값)을 넘으면 다시 -128부터 시작하게 된다.
    - 다른 정수 타입들 역시 저장할 수 있는 값의 범위를 넘어서면 이와 같은 방식으로 처리된다.
    - 이와 같이 저장할 수 있는 값의 범위를 초과해서 값이 저장될 경우 엉터리 값이 변수에 저장되는데, 이러한 값을 쓰레기값이라고 한다.

  <img src="./picture/GarbageValueExample.PNG">

  - byte 변수는 127을 넘어서는 순간 최소값인 -128부터 다시 저장되는 것을 볼 수 있다.



#### char 타입

- 자바는 모든 문자를 유니코드(Unicode)로 처리한다.

  - 유니코드는 세계각국의 문자들을 코드값으로 매핑한 국제 표준 규약이다.
  - 유니코드는 하나의 문자에 대해 하나의 코드값을 부여하기 때문에 영문 'A' 및 한글 '가'도 하나의 코드값을 갖는다.
  - 유니코드는 0~66535 범위의 2byte 크기를 가진 정수값이다.
    - 0~127까지는 아스키(ASCII) 문자(특수기호 및 영어 알파벳)가 할당되어 있고, 44032~55203까지는 한글 11172자가 할당되어 있다.

- 자바는 하나의 유니코드를 저장하기 위해 2byte 크기인 char 타입에 저장할 수 있는 값은 0~65535까지 2<sup>16</sup>개이다.

  - char 타입 변수에 작은 따옴표(')로 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다.

  ```java
  char var1 = 'A';	//유니코드: 0x0041 -> 2진수: 00000000 01000001
  char var2 = 'B';	//유니코드: 0x0042 -> 2진수: 00000000 01000010
  char var3 = '가';	//유니코드: 0xAC00 -> 2진수: 10101100 00000000
  char var4 = '각';	//유니코드: 0xAC01 -> 2진수: 10101100 00000001
  ```

  <img src="./picture/char variable.PNG">

  - char 변수에 작은 따옴표(')로 감싼 문자가 아니라 직접 유니코드 정수값을 저장할 수도 있다.
    - 특정 문자의 유니코드를 안다면 10진수 또는 16진수로 저장하면 된다.
    - 16진수로 저장할 경우에 유니코드라는 의미에서 '\u + 16진수값' 형태로 저장하면 된다.

  ```java
  char c = 65;
  char c = '\u0041';
  ```

  - 프로그램 코드에서 char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면 된다.

  ```java
  char c = 'A';
  int unicode = c;
  ```

  <img src="./picture/CharExample.PNG">

  - 만약 문자열을 저장하고 싶다면 String 타입을 사용해야 하는데, String 변수를 선언하고, 큰 따옴표(")로 감싼 문자열 리터럴을 대입하면 된다.

  ```java
  String name = "홍길동";
  ```

  - String은 기본 타입이 아니다.
    - String은 클래스 타입이고, String 변수는 참조 변수이다.
    - 문자열을 String 변수에 대입하면 문자열이 변수에 직접 저장되는 것이 아니라, String 객체가 생성되고, String 변수는 String 객체의 번지를 참조하게 된다.
  - char 타입의 변수에 어떤 문자를 대입하지 않고 단순히 초기화를 할 목적으로 작은 따옴표(') 두개를 연달아 붙인 빈(empty) 문자를 대입하면 컴파일 에러가 발생한다. 그렇기 때문에 공백(유니코드:32) 하나를 포함해서 초기화해야 한다.

  ````java
  char c = '';	//컴파일 에러 -> char c = ' '
  ````

  - 하지만 String 변수는 큰 따옴표(") 두 개를 연달아 붙인 빈 문자를 대입해도 괜찮다.



#### short 타입

- **short 타입** : 2byte(16bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입이다.
  - 저장할 수 있는 값의 범위는 - 32,768~32,767(-2<sup>15</sup>~(2<sup>15</sup>-1)) 이다.
  - C언어와의 호환을 위해 사용되며 비교적 자바에서는 잘 사용되지 않는 타입이다.



#### int 타입

- **int 타입** : 4byte(32bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입이다.

  - 저장할 수 있는 값의 범위는 -2,147,483,648~2,147,483,647(-2<sup>31</sup>~(2<sup>31</sup>-1)) 이다.

  - int 타입은 자바에서 정수 연산을 하기 위한 기본 타입이다.

    - byte 타입 또는 short 타입의 변수를 +연산하면 int 타입으로 변환된 후 연산되고 연산의 결과 역시 int 타입이 된다.
    - byte 타입이나 short 타입으로 변수를 선언한 것과 int 타입으로 선언한 것의 성능 차이는 거의 없다.

    - 메모리가 크게 부족하지 않다면 정수를 저장할 때는 일반적으로 int 타입을 사용한다.

  - 정수 값을 직접 코드에서 입력할 경우 8진수, 10진수, 16진수로 표현할 수 있다.

    - 8진수일 경우 숫자 앞에 '0'을 붙이면 되고, 16진수는 '0x'를 붙이면 된다.

  ```java
  int number = 10;
  int octNumber = 012;
  int hexNumber = 0xA;
  ```

  - 변수에 어떤 진수로 입력을 하더라도 동일한 값이 2진수로 변환되어 저장된다.
    - 10이 int 타입 변수에 저장되면 int가 4byte의 크기를 가지기 때문에 4byte의 공간을 차지하면서 총 32bit로 10을 표현한다.
    - 10은 1byte로 충분히 표현이 가능하기 때문에 나머지 상위 3byte의 bit 값은 모두 0이다.

  <img src="./picture/int byte.PNG">

  <img src="./picture/IntExample.PNG">



#### long 타입

- **long 타입** : 8byte(64bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입이다.

  - 저장할 수 있는 값의 범위는 -9,223,372,036,854,775,808~9,223,372,036,854,775,807(-2<sup>63</sup>~(2<sup>63</sup>-1)) 이다.

  - 수치가 큰 데이터를 다루는 프로그램에서는 long 타입이 필수적으로 사용된다.

  - long 타입의 변수를 초기화할 때에는 정수값 뒤에 소문자 'l'이나 대문자'L'을 붙일 수 있다.

    - 정수 데이터가 8byte 정수 데이터임을 컴파일러에게 알려주기 위한 목적이다.

    - int 타입의 저장 범위를 넘어서는 큰 정수는 반드시 소문자 'l'이나 대문자 'L'을 붙어야 한다.
    - 일반적으로 소문자 'l'은 숫자 '1'과 비슷해 혼돈하기 쉬우므로 대문자 'L'을 사용한다.

  <img src="./picture/LongExample.PNG">



### 2.2.3 실수 타입(float, double)

- **실수 타입 **: 소수점이 있는 실수 데이터를 저장할 수 있는 타입으로, 메모리 사용 크기에  따라 float와 double이 있다.

  | 실수  타입 | float | double |
  | ---------- | :---: | :----: |
  | 바이트 수  |   4   |   8    |

  - float와 double의 메모리 사용 크기는 각각 int와 long의 크기와 같지만, 정수 타입과는 다른 저장 방식 때문에 정수 타입보다 월씬 더 큰 범위의 값을 저장할 수 있다.
  - 실수는 정수와 달리 부동 소수점(floating-point) 방식으로 저장된다.

  <img src="./picture/actual number.PNG">

  - 가수 m은 0<=m<1 범위의 실수 이어야 한다.
  - float 타입과 double 타입은 가수와 지수를 저장하기 위해 전체 bit를 나누어 사용한다.

  <img src="./picture/actual memory.PNG">

  - 정밀도를 요구하는 계산에서는 double을 사용한다.
    - 자바는 실수 리터럴의 기본 타입을 double로 간주한다.
    - 이 말은 실수 리터럴을 float 타입 변수에 그냥 저장할 수 없다는 뜻이다. 실수 리터럴을 float 타입 변수에 저장하려면 리터럴 뒤에 소문자 'f'나 대문자 'F'를 붙여야 한다.

  ```java
  double var1 = 3.14;
  float var2 = 3.14;	// 컴파일 에러(Type mismatch: cannot convert from double to float)
  float var3 = 3.14F;
  ```

  - 만약 정수 리터럴에 10의 지수를 나타내는 E 또는 e를 포함하고 있으면 정수 타입 변수에 저장할 수 없고 실수 타입 변수에 저장해야 한다.

  ```java
  int var6 = 3000000;		// 3000000
  double var7 = 3e6;		// 3000000
  float var8 = 3e6f;		// 3000000
  double var9 = 2e-3;		// 0.002
  ```

  <img src="./picture/FloatDoubleExample.PNG">

  - double 타입이 float 타입의 가수가 약 두 배 정도 크기 때문에 더욱 정밀하게 출력되는 것을 볼 수 있다.



### 2.2.4 논리 타입(boolean)

- **boolean 타입** : 1byte(8bit)로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입이다.

  - boolean 타입은 두 가지 상태값을 저장할 필요성이 있을 경우에 사용되며, 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용된다.

  <img src="./picture/BooleanExample.PNG">



## 2.3 타입 변환

- **타입 변환** : 데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다.
  - 타입 변환에는 두 가지 종류가 있다. 하나는 자동(묵시적) 타입 변환이고 다른 하나는 강제(명시적) 타입 변환이다.



### 2.3.1 자동 타입 변환

- **자동 타입 변환(Promotion)** : 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.

  - 자동 타입 변환은 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.
  - 큰 크기 타입과 작은 크기 타입의 구분은 사용하는 메모리 크기이다.

  <img src="./picture/promotion.PNG">

  ```
  byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)
  ```

  - 실수 타입의 변수들이 정수 타입의 변수들보다 크기가 큰 이유는  표현할 수 있는 값의 범위가 더 크기 때문이다.

  ```java
  byte byteValue = 10;
  int intValue = byteValue;		// 자동 타입 변환이 일어난다.
  ```

  <img src="./picture/byte int.PNG">

  - 자동 타입 변환이 발생되면 변환 이전의 값과 변환 이후의 값은 동일하다.
    - 변환 이전의 값은 변환 이후에도 손실 없이 그대로 보존된다.
  - 정수 타입이 실수 타입으로 변환하는 것은 무조건 자동 타입 변환이 된다.
    - 실수 타입으로 변환된 이후의 값은 정수가 아닌 .0이 붙은 실수 값이 된다.

  ```java
  int intValue = 200;
  double doubleValue = intValue;		// 200.0
  ```

  - char 타입의 경우 int 타입으로 자동 변환되면 유니코드 값이 int 타입에 저장된다.

  ```java
  char charValue = 'A';
  int intValue = charValue;			// 65
  ```

  - 자동 타입 변환에서의 예외
    - char는 2byte의 크기를 가지지만, char의 범위는 0~65535이므로 음수가 저장될 수 없다. 따라서 음수가 저장될 수 있는 byte 타입을 char 타입으로 자동 변환시킬 수 없다.

  ```java
  byte byteValue = 65;
  char charValue = byteValue;		(o)	// 컴파일 에러
  char charData = (char)byteValue	(x)	// 강제 타입 변환
  ```

  <img src="./picture/PromotionExample.PNG">



### 2.3.2 강제 타입 변환

- 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없다.

- **강제 타입 변환(캐스팅: Casting)** 강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 방법

  - 강제 타입 변환은 캐스팅 연산자 ()를 사용하는데, 괄호 안에 들어가는 타입은 쪼개는 단위이다.

  <img src="./picture/casting.PNG">

  ```java
  int intValue = 103029770;
  byte byteValue = (byte)intValue;			//강제 타입 변환(캐스팅)
  ```

  <img src="./picture/int to byte.PNG">

  - 끝 1byte만 byte 타입 변수에 담게 되므로 원래 int 값은 보존되지 않는다. 하지만 int 값이 끝 1byte로만 표현이 가능하다면 byte 타입으로 변환해도 같은 값이 유지될 수 있다.
    - 이럴 경우 강제 변환이 의미 있게 된다.

  <img src="./picture/int to byte_s.PNG">

  ```java
  long longValue = 300;
  int intValue = (int)longValue;		//intValue는 300이 그대로 저장된다.
  ```

  - int 타입은 char 타입으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다.
    - int 타입에 저장된 값이 유니코드 범위(0~65535)라면 (char) 캐스팅 연산자를 사용해서 char 타입으로 변환할 수 있다.
    - char 타입으로 변환된 값을 출력하면 유니코드에 해당하는 문자가 출력된다.

  ```java
  int intValue = 'A';
  char charValue = (char)intValue;
  System.out.println(charValue);
  ```

  - 실수 타입(float, double)은 정수 타입(byte, short, int, long)으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다.
    - 이 경우 소수점 이하 부분은 버려지고, 정수 부분만 저장된다.

  ```java
  double doubleValue = 3.14;
  int intValue = (int)doubleValue;	// intValue는 정수 부분인 3만 저장된다.
  ```

  <img src="./picture/CastingExample.PNG">

  - 강제 타입 변환에서 주의할 점은 사용자로부터 입력받은 값을 변환할 때 값의 손실이 발생하면 안된다는  것이다.
    - 강제 타입 변환을 하기 전에 우선 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.

  <img src="./picture/CheckValueBeforeCasting.PNG">

  - 자바는 코드에서 데이터 값을 검사하기 위해 boolean과 char 타입을 제외하고 모든 기본 타입에 대해 최대값(max)과 최소값(min)을 상수로 제공하고 있다.
  - 어떤 정수값과 실수값을 다른 타입으로 변환하고자 할 때는 변환될 타입의 최소값과 최대값을 벗어나는지 반드시 검사하고, 만약 벗어난다면 타입 변환을 하지 말아야 한다.

  | 기본 타입 | 최대값 상수       | 최소값 상수       |
  | --------- | ----------------- | ----------------- |
  | byte      | Byte.MAX_VALUE    | Byte.MIN_VALUE    |
  | short     | Short.MAX_VALUE   | Short.MIN_VALUE   |
  | int       | Integer.MAX_VALUE | Integer.MIN_VALUE |
  | long      | Long.MAX_VALUE    | Long.MIN_VALUE    |
  | float     | Float.MAX_VALUE   | Float.MIN_VALUE   |
  | double    | Double.MAX_VALUE  | Double.MIN_VALUE  |

  - 강제 타입 변환에서 또 다른 주의할 점은 정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야 한다.

  <img src="./picture/FromIntToFloat.PNG">

  - 다음과 같이 값이 나온 이유는 int 값을 float 타입으로 자동 변환하면서 문제가 발생했기 때문이다.

  ```
  float: 부호(1비트) + 지수(8비트) + 가수(23비트)
  ```

  - float 타입은 다음과 같이 비트 수가 할당되어 있다.
  - int 값을 손실 없이 float 타입의 값으로 변환할 수 있으려면 가수 23비트로 표현 가능한 값이어야 한다.
    - 123465780은 23비트로 표현할 수 없기 때문에 근사치로 변환된다. 즉 정밀도 손실이 발생한다.
    - 그렇기 때문에 int 갑을 실수 타입으로 안전하게 변환시키는 double 타입을 사용한다.

  ```
  double: 부호(1비트) + 지수(11비트) + 가수(52비트)
  ```

  - int의 크기는 32비트이므로 double의 가수 52비트보다 작기 때문에 어떠한 int 값이라도 안전하게 정밀도 손실 없이 double 타입으로 변환될 수 있다.
    - double 값을 원래 int 타입으로 변환해도 손실 없이 복원 된다.

  <img src="./picture/FromIntToDouble.PNG">



### 2.3.3 연산식에서의 자동 타입 변환

- 연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행되기 때문에 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.

  <img src="./picture/promotion operating.PNG">

  - int 타입으로 반드시 연산을 해야 한다면 double 타입을 int 타입으로 강제 변환하고 덧셈 연산을 수행해야 한다.

  ```java
  int intValue = 10;
  double doubleValue = 5.5;
  int result = intValue + (int)doubleValue;		//result에 15가 저장
  ```

  - 자바는 정수 연산일 경우 int 타입을 기본으로 한다.
    - 피연산자를 4byte 단위로 저장하기 때문이다.
    - 크기가  4byte보다 작은 타입(byte, char, short)은 4byte인 int 타입으로 변환된 후 연산이 수행된다.
    - 따라서 연산의 결과도 int 타입이 된다.

  <img src="./picture/promotion int.PNG">

  - 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 타입으로 자동 타입 변환되고 연산 결과는 long 타입이 된다.

  <img src="./picture/promotion long.PNG">

  - float 타입과 float 타입을 연산하면 연산의 결과는 float 타입으로 나오지만, 피연산자 중에 실수 리터럴이나 double 타입이 있다면 다른 피연산자도 double 타입으로 자동 타입 변환되어 연산되므로 결과는 double 타입으로 산출된다.

  <img src="./picture/promotion double.PNG">

  <img src="./picture/OperationsPromotionExample.PNG">

