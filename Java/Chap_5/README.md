# 5. 참조 타입

## 5.1 데이터 타입 분류

- 프로그램이 하는 일은 결국 데이터를 처리하는 것이다.

  - 따라서 데이터를 얼마나 잘 다루느냐가 좋은 프로그램을 작성할 수 있는 관건이 된다.
  - 데이터를 잘 다루기 위해서는 자바에서 지원하는 데이터 타입에 대해서 제대로 이해할 필요가 있다.
  - 자바의 데이터 타입에는 크게 기본 타입(원시 타입: prmitive type)과 참조 타입(reference type)으로 분류된다.
    - **기본 타입** : 정수, 실수, 문자열, 논리 리터럴을 저장하는 타입을 말한다.
    - **참조 타입** : 객체(Object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말한다.

  <img src="./picture/variable.png">

  - 기본 타입으로 선언된 변수와 참조 타입으로 선언된 변수의 차이점은 저장되는 값이 무엇이냐이다.
    - 기본 타입인 byte, char, shor, int, long, float, double, boolean을 이용해서 선언된 변수는 실제 값을 변수 안에 저장한다. 
    - 참조 타입인 배열, 열거, 클래스, 인터페이스를 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다. 번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다.

  <img src="./picture/primi_refer.PNG">

  ```java
  [기본 타입 변수]
  int age = 25;
  double price = 100.5;
  
  [참조 타입 변수]
  String name = "신용권";
  String hobby = "독서";
  ```

  <img src="./picture/heap_stack.png">

  - 메모리상에서 변수들이 갖는 값에 대해 알아보면 변수는 스택 영역에 생성되고, 객체는 힙 영역에 생성되는 것을 볼 수 있다.

## 5.2 메모리 사용 영역

- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 세부 영역으로 구분해서 사용한다.

  <img src="./picture/RDA.png">

### 5.2.1 메소드(Method) 영역

- 메소드 영역에는 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 런타임 상수풀(runtime constant pool), 필드(field) 데이터, 메소드(method) 데이터, 메소드 코드, 생성자(constructor) 코드 등을 분류해서 저장한다.
  - 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.

#### 힙(heap) 영역

- **힙 영역** : 객체와 배열이 생성되는 영역이다.
  - 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
  - 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 이것을 쓰레기로 취급하고 JVM은 쓰레기 수집기(Garbage Collector)를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거한다.
  - 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없다.
    - 사실 자바는 코드로 객체를 직접 제거시키는 방법을 제공하지 않는다고 한다.

#### JVM 스택(Stack) 영역

- JVM 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.

  - 자바 프로그램에서 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하므로 JVM 스택도 하나이다.
  - JVM 스택은 메소드를 호출할 때마다 프레임(frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
  - 예외 발생 시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을  표현한다.
  - 프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
    - 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
    - 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

  ```java
  1. char v1 = 'A';
  
  2. if(v1 == 'A'){
  	int v2 = 100;
  	double v3 = 3.14;
  }
  
  3. boolean v4 = true;
  ```

  <img src="./picture/Stack_area.PNG">
  - 기본 타입 변수는 스택 영역에 직접 값을 가지고 있지만, 참조 타입 변수는 값이 아니라 힙 영역이나 메소드 영역의 객체 주소를 가진다.

  ```java
  int[] scores = {10, 20, 30};
  ```

  <img src="./picture/reference.PNG">

## 5.3 참조 변수의 ==, != 연산

- 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.

  - 참조 타입 변수 =의 값은 힙 영역의 객체 주소이므로 결국 주소 값을 비교하는 것이 된다.
    - 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
    - 따라서 동일한 객체를 참조하고 있을 경우 == 연산의 결과는 true이고 != 연산의 결과는 false이다.

  <img src="./picture/equal_address.png">

  ```
  refVar1 == refVar2	결과: false
  refVar1 != refVar2	결과: true
  
  refVar2 == refVar3	결과: true
  refVar2 != refVar3	결과: false
  ```

## 5.4 null과 NullPointerException

- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null(널) 값을 가질 수 있다.

  - null 값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 생성된다.

  <img src="./picture/null.png">

  ```
  refVar1 == null	결과: false
  refVar1 != null	결과: true
  
  refVar2 == null	결과: true
  refVar2 != null	결과: false
  ```

  - 자바 프로그램 실향 도중에 발생하는 오류를 예외(Exception)라고 부른다.
    - 예외는 사용자의 잘못된 입력으로 발생하 수도 있고, 프로그래머가 코드를 잘못 작성해서 발생할 수도 있다.
    - 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나로 NullPointerException이 있다.
      - 이 예외는 참조 타입 변수를 잘못 사용하면 발생한다.
  - 참조 타입 변수가 null을 가지고 있을 경우, 참조 타입 변수는 사용할 수 없다.
    - NullPointerException은 사용자가 null을 가지고 있는 참조 타입 변수를 사용하였을 때 발생하는 예외이다.

  ```java
  int[] intArray = null;
  intArray[0] = 10;	//NullPointerException
  ```

  ```java
  String str = null;
  System.out.println("총 문자수: " + str.length());	//NullPointerException
  ```

  - 프로그램 실행 도중 NullPointerException이 발생하면, 예외가 발생된 곳에서 객체를 참조하지 않은 상태로 참조 타입 변수를 사용하고 있음을 알아야 한다.

## 5.5 String 타입

- 자바는 문자열을 String 변수에 저장하기 때문에 String 변수를 선언해야 한다.

  ```java
  String 변수;
  ```

- String 변수에 문자열을 저장하려면 큰 따옴표로 감싼 문자열 리터럴을 대입하면 된다.

  ```java
  변수 = "문자열";
  ```

- 변수 선언과 동시에 문자열을 저장할 수도 있다.

  ```java
  String 변수 = "문자열";
  ```

  ```java
  String name;
  name = "신용권";
  String hobby = "자바";
  ```

  <img src="./picture/String_variable.png">

- 사실 문자열을 String 변수에 저장한다는 표현은 틀린 표현이다.

  - 문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String 객체로 생성되고 변수는 String 객체를 참조한다.
  - 하지만 일반적으로 String 변수에 저장한다는 표현을 사용한다.

- 자바는 문자열 리터럴이 동일하다면 String 갹체를 공유하도록 되어 있다.

  ```java
  String name1 = "신용권";
  String name2 = "신용권";
  ```

  <img src="./picture/same_object.png">

- 일반적으로 변수에 문자열을 저장할 경우에는 문자열 리터럴을 사욯하지만, new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다.

  - new 연산자는 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 한다.

  ```java
  String name1 = new String("신용권");
  String name2 = new String("신용권");
  ```

  <img src="./picture/different_object.png">

- 문자열 리터럴로 생성하느냐 new 연산자로 생성하느냐에 따라 비교 연산자의 결과가 달라질 수 있다.

  - 동일한 문자열 리터럴로 String 객체를 생성했을 경우 == 연산의 결과는 true가 나오지만, new 연산자로 String 객체를 생성했을 경우 == 연산의 결과는 false가 나온다.
  - == 연산자는 변수에 저장된 객체 번지가 동일한 지를 검사하기 때문이다.

  ```java
  String name1 = "신민철";
  String name2 = "신민철";	// name1 == name2(true)
  String name3 = new String("신민철");	// name1 == name3(false)
  ```

- 동일한 String 객체이건 다른 String 객체이건 상관없이 문자열만을 비교할 때에는 String 객체의 equals() 메소드를 사용해야 한다.

  - equals() 메소드는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한 후 true 또는 false를 리턴한다.

  ```java
  boolean result = str1.equals(str2);
  ```

- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.

  - null은 String 변수가 참조하는 String 객체가 없다는 뜻이다.

  ```java
  String hobby = null;
  ```

  - String 변수가 객체를 참조하였으나, null을 대입함으로써 더 이상 String 객체를 참조하지 않도록 할 수도 있다.

  ```java
  String hobby = "여행";
  hobby = null;
  ```

  - 참조를 잃은 String 객체는 JVM은 참조되지 않은 객체를 쓰레기 객체로 취급하고 쓰레기 수집기(Garbage Collector)를 구동시켜 메모리에서 자동 제거한다.

## 5.6 배열 타입

### 5.6.1 배열이란?

- 변수는 한 개의 데이터만 저장할 수 있다.

  - 따라서 저장해야 할 데이터의 수가 많아지면 그만큼 많은 변수가 필요하다.

  `30명의 성적을 저장하고 평균 값을 구하는 예제`

  ```java
  int score1 = 83;
  int score2 = 90;
  int score3 = 87;
  ...
  int score30 = 75;
  
  int sum = score1;
  sum += score2;
  ...
  sum += score30;
  int avg = sum / 30;
  ```

  - 일일이 변수를 선언하고 연산을 수행하는 것은 매우 비효율적이고 지루한 코딩이 된다.

- 같은 타입의 많은 양의 데이터를 다루는 프로그램에서는 좀 더 효율적인 방법이 필요한데 이것이 배열이다.

- **배열** : 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.

  <img src="./picture/array.png">

  ```java
  int sum = 0;
  for(int i = 0; i < 30; i++){
  	sum += sum score[i];
  }
  int avg = sum / 30
  ```

- 배열은 같은 타입의 데이터만 저장할 수 있다,

  - int 배열은 int 값만 저장 가능하고, String 배열은 문자열만 저장 가능하다.
  - 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
  - 만약 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 오류가 발생한다.

- 배열은 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.

  `3개의 값을 저장하는 배열을 생성하였을 때 프로그램 실행 도중에 5개의 값을 저장하는 배열로 수정할 수 없고, 반대로 2개의 값만 저장하는 배열로 수정할 수도 없다. 만약 5개의 값을 저장해야 하는 경우가 발생한다면, 길이 5의 새로운 배열을 생성하고, 기존 배열 항목을 새 배열로 복사해야 한다.`

### 5.6.2 배열 선언

- 배열을 사용하기 위해서는 배열 변수를 선언해야 한다.

  ```java
  타입[] 변수;
  타입 변수[];
  ```

  - 대괄호 []는 배열 변수를 선언하는 기호로 사용되는데, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다.
  - 타입은 배열에 저장될 데이터의 타입을 말한다.

  ```java
  int[] intArray;
  int intArray[];
  ```

- 배열 변수는 참조 변수에 속한다.

  - 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
  - 참조된 배열 객체가 없다면 배열 변수는 null 값으로 초기화될 수 있다.

  ```java
  타입[] 변수 = null;
  ```

  - 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다.
  - 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.

### 5.6.3 값 목록으로 배열 생성

- 배열 항목에 저장될 값의 목록이 있다면, 간단한 배열 객체를 만들 수 있다.

  ```java
  타입[] 변수 = {값0, 값1, 값2, 값3, ...};
  ```

  <img src="./picture/array_init.png">
  - 중괄호 {}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴한다.
  - 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.

  ```java
  String[] names = {"신용권", "홍길도", "감자바"};
  ```

  - 만약 배열 특정 인덱스의 리터럴을 바꾸고 싶다면 대입 연산자를 사용하여 해당 인덱스의 값을 변경하면 된다.

  ```java
  names[1] = "홍삼원"
  ```

- 값의 목록으로 배열 객체를 생성할 때 주의할 점이 있는데, 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다.

  ```java
  타입[] 변수;
  변수 = {값0, 값1, 값2, ...};	// 컴파일 에러
  ```

  - 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 new 연산자를 사용해서 값 목록을 지정해주면 된다.
    - new 연산자 바로 뒤에는 배열 변수 선언에서 사용한 "타입[]"를 붙여주고 중괄호{}에는 값들을 나열해주면 된다.

  ```java
  변수 = new 타입[] {값0, 값1, 값2, ...};
  ```

  ```java
  String[] names = null;
  names = new String[] { "신용권", "홍길동", "감자바" };
  ```

  - 메소드의 매개값이 배열일 경우에도 마찬가지다.
    - 반드시 new 연산자를 사용하여야 한다.

  ```java
  int add(int[] scores) {...}
  
  int result = add( {95, 85, 90} );	// 컴파일 에러
  int result = add(new int[] {95, 85, 90});
  ```